README

Описание

Данный код представляет собой реализацию пользовательского пула потоков (thread pool) на языке Java под названием CustomThreadPool. Пул потоков используется для управления и повторного использования потоков, что позволяет эффективно выполнять множество асинхронных задач и избегать накладных расходов на создание и уничтожение потоков для каждой задачи.
Основные компоненты

CustomExecutor (интерфейс):
Определяет базовый контракт для пользовательских исполнителей (executors) задач. Содержит методы execute, submit, shutdown и shutdownNow.
CustomThreadFactory:
Фабрика для создания потоков, которая позволяет задавать имена потокам (для удобства отладки) и обрабатывать необработанные исключения, возникающие в потоках.
CustomThreadPool:
Основной класс, реализующий логику пула потоков.
Содержит параметры конфигурации (количество основных потоков, максимальное количество потоков, время простоя потока, емкость очереди задач и т. д.).
Управляет жизненным циклом потоков и распределением задач между ними.
Использует блокирующую очередь для хранения задач, ожидающих выполнения.
Предоставляет методы для запуска задач (execute, submit), завершения работы пула (shutdown, shutdownNow).
CustomRejectionHandler:
Реализация RejectedExecutionHandler, обрабатывает задачи, которые не могут быть приняты пулом (например, при перегрузке). По умолчанию, выполняет задачу в текущем потоке (CallerRunsPolicy).
Main:
Пример использования CustomThreadPool.
Создает пул, отправляет в него несколько задач, имитирующих выполнение работы (засыпание на некоторое время), и завершает работу пула.
Конфигурация CustomThreadPool

Параметры пула потоков задаются в конструкторе CustomThreadPool:
coreThreads: Минимальное количество потоков, которое постоянно поддерживается в пуле.
maxThreads: Максимальное количество потоков, которое может быть создано в пуле при увеличении нагрузки.
idleTimeout: Время, в течение которого простаивающий поток может быть завершен, если количество потоков превышает coreThreads.
timeUnit: Единица измерения для idleTimeout (например, TimeUnit.SECONDS, TimeUnit.MILLISECONDS).
minIdle: Минимальное количество простаивающих потоков, которое пул старается поддерживать.
queueCapacity: Максимальная емкость очереди задач, ожидающих выполнения.
rejectionHandler: Обработчик отклоненных задач (реализация интерфейса RejectedExecutionHandler). Определяет, что делать, если пул перегружен и не может принять новую задачу.
Запуск и завершение работы пула

Для запуска задачи в пуле используется метод execute(Runnable task) или submit(Callable<T> task).
Для “мягкого” завершения работы пула (дождаться завершения всех текущих задач) используется метод shutdown().
Для немедленного завершения работы пула (прервать все текущие задачи и отбросить ожидающие) используется метод shutdownNow().
Обработка отклоненных задач

Когда пул перегружен и не может принять новую задачу, вызывается rejectionHandler. По умолчанию, используется CallerRunsPolicy, который выполняет задачу в потоке, вызвавшем метод execute(). Можно реализовать другую политику (например, отбросить задачу, бросить исключение и т. д.).
Как использовать код

Скомпилируйте все файлы Java.
Запустите класс Main для демонстрации работы пула потоков.
Настройте параметры пула потоков в классе Main в соответствии с требованиями вашего приложения.
Используйте CustomThreadPool в своих проектах для эффективного управления асинхронными задачами.
Зависимости

Java Development Kit (JDK) 8 или выше.
Стандартные библиотеки Java (java.util.concurrent).
Дополнительные замечания

Данный код предоставляет базовую реализацию пула потоков. Для более сложных сценариев может потребоваться расширение функциональности (например, добавление мониторинга, управления приоритетами задач и т. д.).
В коде используются блокировки (synchronized) для обеспечения потокобезопасности. Неправильное использование блокировок может привести к взаимоблокировкам (deadlocks), поэтому необходимо тщательно продумывать архитектуру многопоточных приложений.
При выборе параметров конфигурации пула потоков необходимо учитывать характеристики задач, которые будут выполняться, и доступные ресурсы системы.
